================================
   Whats new in Castor 1.1 
================================

Enhancements to lref:
---------------------
- Now lrefs can reference existing objects via pointers. A new constructor lref(T*,bool) and a 
  method set_ptr(T*,bool) added to support this. bool parameter specifies if object's lifetime should be managed.
     + item() relation now uses set_ptr instead of performing an element wise copy into the lref.
- lref::operator=(rhs) will reset the lref if rhs is not initialized
- lref::bound(lref& rhs) will check if this lref and rhs are bound/joined together

// - Relations supporting Fast && : False, Boolean, predicate, predicate_mf, predicate_mem, defined, undefined, negate
- Function ref() to construct a non-managing lref to an object.
     E.g.   lref<int> i=2;  eval(ref(cout)<<i)();
     
Enhancements to ILE (closure/lambda facility):
----------------------------------------------
- New named ILEs have been provided:
    + at - Allows indexed access. Equivalent to the operator []. 
        E.g.   lref<string> str=..; cout << at(str,0)();
    + create - To create an new object. Equivalent to operator new. Supercedes Create::with(). 
        E.g.   create<int>(1); create<pair<int,int> >(1,2);  create<string,const char*>("castor");  
    + get - To access a data member of an object. 
        E.g.   lref<pair<int,int> > pr .. ; write_f( get(pr,&pair:;first) ) 
    + mcall - To invoke a member function with upto 6 arguments. 
        E.g.   lref<string> str= "hello" ;  predicate( mcall(str, &string::at,0)=='h' )
    + call - To invoke a function/function object with upto 6 arguments.
        E.g.   eq_f(x, call(&foo,1,2,3); eq_f(3, call(plus<int,int>(),1,2) ) 

Enhancements:
-------------
- Class Coroutine and macros co_begin, co_end, co_return & co_yield that support coroutine style programming
  Helpful for defining relations imperatively.
- New overloads for the following relations that take function pointer or member function pointer as
  argument. These overloads allow passing an *overloaded* function (or method) to these
  relations without requiring explicit overload disambiguation. Also arguments to be forwarded can be 
  POTs or lrefs :
  + Additional overloads for eq_f, eq_mf, predicate_f, predicate_mf, writeAll_f and writeAll_mf.
  + Signatures for eq_f, predicate_f and writeAll_f modified (new signatures continue to be backward compatible).

- Enhanced relations: Additional constructor for relation True that takes an integral argument denoting how many times to succeed.

New relations: 
--------------
- eq_mem() - for unifying with (non static) data members.
- eval() and eval_mf() - To execute and function or member function. Return value (if any) is discarded.
- error() - To throw an exception. 
- pause() - To pause execution. Waits for a key press by calling cin.ignore(). Helpful as a debugging aid.
- permute() -  To generate permutations of a sequnce/string.
- ritem() -  To generate values from a sequence in reverse. The sequence must provide rbegin() and rend().
- shuffle() - To generate a randomized sequence/string.
- unique_mem(), unique_mf() - Similar to unique() but filtering is based on a data member or value returned by a method call.
- writeAll(), writeAllTo() : To print write all elements in a sequence to cout or to a stream.
- write_mem(), writeTo_mem() : To print value of a data member to cout or a stream.

- Special Relations to be used with operator >> : 
   + count() - For counting the number of items in a sequence. e.g. range(i,1,10) >> count(n)
   + group_by() - For grouping objects based on some criteria. Allows nested grouping. e.g
        E.g: 
        // Group strings by first char & then by length
        
        char firstChar(const string& s) { return s[0]; };
        char str_len(const string& s) { return s.size(); };
        
        lref<string> n;
        lref<vector<string> > names ;
        lref<group<char,group<size_t,string> > > g;
        relation r = item(n,names) >> group_by(n, &firstChar, g).then(&str_len);
        while(r()) {
           cout << "\n" << g->key;
           lref<group<size_t,string> > g2;
           relation subgroups = item(g2,g);
           while(subgroups()) {
                cout << "\n   " << g2->key << " : ";
                lref<string> s;
                relation values = item(s,g2);
                while(values()) cout << *s << " ";
           }
        }
   + order() - For producing a sorted sequence of objects.
   + order_mem() - For producing a sorted sequence of objects. Sort objects on a data member. (e.g. pair<,>.first )
   + order_mf() - For producing a sorted sequence of objects. Sort based on value method call (e.g. string::length() )
   + reverse() - For reversing a sequence of objects. e.g. range(i,1,10) >> reverse(i)
   + reduce() - For reducing a sequence to a value by applying a operator(similar to accumulate). e.g.
         range(j,1,10) >> reduce(j, std::multiplies<int>()); // product of first 10 numbers
   + sum - For summing the values in a sequence. e.g. range(i,1,10) >> sum(i)



Deprecated:
-----------
In order to use the following deprecated facilites a #define CASTOR_ENABLE_DEPRECATED is required.
- The Named ILE Create::With() is now deprecated. Prefer using the named ILE create().
- OneSolution relation is now deprecated. Use class Coroutine instead.


Potential Incompatibilites:
---------------------------
- item() relation now yields an lref<> that references the actual element in the container/sequence 
  instead of a copy.


Bug fixes:
----------
- head_n and tail_n now fails instead of throwing exception if n>seq_.size()
- UnifyL  ... had a const member relation preventing copy construction
- Data member Read_r<T>::in is now a pointer instead of a reference to allow assignment of Read_r.
- Added #include<cstring.h> in eq.h  (Thanks to David Côme)
- Added #include<algorithm> in refcountedptr.h
- Exception types InvalidDeref and Underflow moved to namespace castor.