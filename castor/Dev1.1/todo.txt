  Todo
------------
MUST
group_by:
- member function support for group_by
- consider case of empty groups... if(first==last)

- make all aggregates uni/bidirectional
- Wrap up aggregates (consider renaming them .."eager" ?)
- look into constraining generic operator && and ||
- define operator & , | as alternatives

- dont release error() without catch()
+ operator >> should be replaced with >>=
+ review shuffle and permute

ILE:
> ILE support for []
> Update example in eq_mem ref manual to use sum()
> test ILEs with const objects
+ can empty base class optimization be applied to ILEs - no use
+ optimize ILEs



LATER
> ILE support for _1 _2
> Assignment operator support for ILEs 
> is it really necessary to derive ILE classes from binary_function or unary_function ?
> Try quick-select algorithm for group_by
> random()
> Left recursion 
> dynamic programming/Memoization support
> Consider removing member typedef UseFastAnd and just rely on method reset()
- writeAll_f(), writeAll_mf() 
- writeAllTo_f(), writeAllTo_mf() 



- Split
- Fast-testOnly relations
  + Add fast&& support for && if both args support fast &&
  + CutAnd needs support for fast && 
 ?+ Consider adding fast && support to relation empty  - (but one of its overloads may not qualify)
- Consider alternative unification using binding instead of assignment as in eq() - for simulating Prolog behavior


- Tabling support
- Look into perfect forwarding issues with create
?- relations readAll and readAllFrom

- Implement head_n, head_tail etc. in terms of views instead of lists.


Document:
    - ILE at(), ref()
    - ritem
	- all eager relations - fial immdly if out param is initialized
	- Coroutines should not have const and reference data members
	- 2 co_yields on same line wont work, local variables wont work without exta {} for if/else blocks:
			if(..)
				co_yield(..);
			else
				co_yield(..);
	- normally passing local POT variables to relations is disastrous unless the members of the POT are all lrefs.
	- 	{ // invoking const and non const operator() 
			const Func cf=Func();
			if(call<const Func>(cf,4)() != 4)
				throw "failed test_call 3";
			if(call<Func>(cf,4)() != 5)
				throw "failed test_call 3";
		}

  
