  Todo
------------
MUST
- Consider splitting set_ptr into two nullary methods
- Item should be able to support random lookup for containers
- Boost Coroutines
- Wrap up aggregates (consider renaming them .."TakeLeft" ?)
- Breakup into namespaces/ headers 
   - core(eq, relation, lref, ile, higher_order, cut, predicate, eval, recurse)
   - named_ile, io, utils(util,collection), aggregates
   - Move helper headers into detail directory

group_by:
?- member function support for group_by
+ consider case of empty groups... if(first==last)

- Look into constraining generic operator && and ||
- define operator & , | as alternatives

+ do not release error() without catch()
+ operator >> should be replaced with >>=
+ review shuffle and permute
+ make all aggregates unidirectional

ILE:
> ILE support for []
> Update example in eq_mem ref manual to use sum()
> test ILEs with const objects
+ can empty base class optimization be applied to ILEs - no use
+ optimize ILEs


LATER
> consider bidirectionality for all TakeLeft relations
> ILE support for positional parameters _1 _2
> Assignment operator support for ILEs 
> is it really necessary to derive ILE classes from binary_function or unary_function ?
> Try quick-select algorithm for group_by
> random()
> Left recursion 
> dynamic programming/Memoization support
> Consider removing member typedef UseFastAnd and just rely on method reset()
- writeAll_f(), writeAll_mf() 
- writeAllTo_f(), writeAllTo_mf() 
- split
- Fast-testOnly relations
  + Add fast&& support for && if both args support fast &&
  + CutAnd needs support for fast && 
 ?+ Consider adding fast && support to relation empty  - (but one of its overloads may not qualify)
- Alternative unification using binding instead of assignment as in eq() - for simulating Prolog behavior


- Tabling support
- Look into perfect forwarding issues with create
?- relations readAll and readAllFrom

- Implement head_n, head_tail etc. in terms of views instead of lists.


Document:
    - ILE at(), ref()
    - pause
	- all eager relations - fial immdly if out param is initialized
	- Coroutines should not have const and reference data members
	- 2 co_yields on same line wont work, local variables wont work without exta {} for if/else blocks:
			if(..)
				co_yield(..);
			else
				co_yield(..);
	- normally passing local POT variables to relations is disastrous unless the members of the POT are all lrefs.
	- 	{ // invoking const and non const operator() 
			const Func cf=Func();
			if(call<const Func>(cf,4)() != 4)
				throw "failed test_call 3";
			if(call<Func>(cf,4)() != 5)
				throw "failed test_call 3";
		}

  
